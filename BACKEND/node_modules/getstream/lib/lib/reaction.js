var errors = require('./errors');

var StreamReaction = function StreamReaction() {
  this.initialize.apply(this, arguments);
};

StreamReaction.prototype = {
  initialize: function initialize(client, token) {
    /**
     * Initialize a feed object
     * @method intialize
     * @memberof StreamReaction.prototype
     * @param {StreamClient} client Stream client this feed is constructed from
     * @param {string} token JWT token
     * @example new StreamReaction(client, "eyJhbGciOiJIUzI1...")
     */
    this.client = client;
    this.token = token;
    this.signature = token;
  },
  buildURL: function buildURL() {
    var url = 'reaction/';

    for (var i = 0; i < arguments.length; i++) {
      url += arguments[i] + '/';
    }

    return url;
  },
  all: function all(options, callback) {
    /**
     * get all reactions
     * @method all
     * @memberof StreamReaction.prototype
     * @param  {object}   options  {limit:}
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.all()
     * @example reactions.all({limit:100})
     */
    return this.client.get({
      url: this.buildURL(),
      signature: this.signature
    }, callback);
  },
  _convertTargetFeeds: function _convertTargetFeeds() {
    var targetFeeds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return targetFeeds.map(function (elem) {
      return typeof elem === 'string' ? elem : elem.id;
    });
  },
  add: function add(kind, activity) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        id = _ref.id,
        data = _ref.data,
        targetFeeds = _ref.targetFeeds;

    var callback = arguments.length > 3 ? arguments[3] : undefined;

    /**
     * add reaction
     * @method add
     * @memberof StreamReaction.prototype
     * @param  {string}   kind  kind of reaction
     * @param  {string}   activity Activity or an ActivityID
     * @param  {object}   data  data related to reaction
     * @param  {array}    targetFeeds  an array of feeds to which to send an activity with the reaction
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.add("like", "0c7db91c-67f9-11e8-bcd9-fe00a9219401")
     * @example reactions.add("comment", {"id": "0c7db91c-67f9-11e8-bcd9-fe00a9219401", "text": "I climbed a mountain"}, {"text": "love it!"},)
     */
    if (activity instanceof Object) {
      activity = activity.id;
    }

    targetFeeds = this._convertTargetFeeds(targetFeeds);
    var body = {
      activity_id: activity,
      kind: kind,
      id: id,
      data: data,
      target_feeds: targetFeeds
    };
    return this.client.post({
      url: this.buildURL(),
      body: body,
      signature: this.signature
    }, callback);
  },
  get: function get(id, callback) {
    /**
     * get reaction
     * @method add
     * @memberof StreamReaction.prototype
     * @param  {string}   id Reaction Id
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.get("67b3e3b5-b201-4697-96ac-482eb14f88ec")
     */
    return this.client.get({
      url: this.buildURL(id),
      signature: this.signature
    }, callback);
  },
  filter: function filter(conditions, callback) {
    /**
     * retrieve reactions by activity id or user_id, pagination can be done using id_lt, id_lte, id_gt and id_gte parameters
     * id_lt and id_lte return reactions order by creation descending starting from the reaction with the ID provided, when id_lte is used
     * the reaction with ID equal to the value provided is included.
     * id_gt and id_gte return reactions order by creation ascending (oldest to newest) starting from the reaction with the ID provided, when id_gte is used
     * the reaction with ID equal to the value provided is included.
     * results are limited to 25 at most and are ordered newest to oldest by default.
     * @method lookup
     * @memberof StreamReaction.prototype
     * @param  {object}   conditions Reaction Id {activity_id|user_id|foreign_id:string, kind:string, next:string, previous:string, limit:integer}
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.lookup({activity_id: "0c7db91c-67f9-11e8-bcd9-fe00a9219401", kind:"like"})
     * @example reactions.lookup({user_id: "john", kinds:"like"})
     */
    var qs = {
      limit: conditions.limit ? conditions.limit : 20
    };

    if (conditions.id_lt) {
      qs.id_lt = conditions.id_lt;
    }

    if (conditions.id_lte) {
      qs.id_lte = conditions.id_lte;
    }

    if (conditions.id_gt) {
      qs.id_gt = conditions.id_gt;
    }

    if (conditions.id_gte) {
      qs.id_gte = conditions.id_gte;
    }

    if (conditions.user_id && conditions.activity_id) {
      throw new errors.SiteError('Cannot use both activity_id and user_id params');
    }

    if (!conditions.user_id && !conditions.activity_id) {
      throw new errors.SiteError('Must use either activity_id or user_id param');
    }

    var lookupType = conditions.user_id ? 'user_id' : 'activity_id';
    var value = conditions.user_id ? conditions.user_id : conditions.activity_id;
    var url = this.buildURL(lookupType, value);

    if (conditions.kind) {
      url = this.buildURL(lookupType, value, conditions.kind);
    }

    return this.client.get({
      url: url,
      qs: qs,
      signature: this.signature
    }, callback);
  },
  update: function update(id, _ref2, callback) {
    var data = _ref2.data,
        targetFeeds = _ref2.targetFeeds;

    /**
     * update reaction
     * @method add
     * @memberof StreamReaction.prototype
     * @param  {string}   id Reaction Id
     * @param  {object}   data  Data associated to reaction
     * @param  {array}   targetFeeds  Optional feeds to post the activity to. If you sent this before and don't set it here it will be removed.
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.update("67b3e3b5-b201-4697-96ac-482eb14f88ec", "0c7db91c-67f9-11e8-bcd9-fe00a9219401", "like")
     * @example reactions.update("67b3e3b5-b201-4697-96ac-482eb14f88ec", "0c7db91c-67f9-11e8-bcd9-fe00a9219401", "comment", {"text": "love it!"},)
     */
    targetFeeds = this._convertTargetFeeds(targetFeeds);
    var body = {
      data: data,
      target_feeds: targetFeeds
    };
    return this.client.put({
      url: this.buildURL(id),
      body: body,
      signature: this.signature
    }, callback);
  },
  delete: function _delete(id, callback) {
    /**
     * delete reaction
     * @method delete
     * @memberof StreamReaction.prototype
     * @param  {string}   id Reaction Id
     * @param  {requestCallback} callback Callback to call on completion
     * @return {Promise} Promise object
     * @example reactions.delete("67b3e3b5-b201-4697-96ac-482eb14f88ec")
     */
    return this.client.delete({
      url: this.buildURL(id),
      signature: this.signature
    }, callback);
  }
};
module.exports = StreamReaction;